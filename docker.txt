查看端口与进程对应关系   lsof -i:6001

Docker有两个主要的部件：
    Docker: 开源的容器虚拟化平台。
    Docker Hub: 用于分享、管理Docker容器的Docker SaaS平台。
Docker使用客户端-服务器(client-server)架构模式。Docker客户端会与Docker守护进程进行通信。
Docker守护 进程会处理复杂繁重的任务，例如建立、运行、发布你的Docker容器。
Docker客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker客户端去
连接一个远程的Docker守护进程。Docker客户端和守护进程之间通过socket或者RESTful API进行通信。


要理解Docker的内部构建，必须知道以下三种部件：
  Docker镜像 (Docker images)。
  Docker仓库 (Docker registeries)。
  Docker容器(Docker containers)。

  Docker镜像是一个只读的模板
  Docker仓库用来保存镜像。可以理解为代码控制中的代码仓库。同样的，Docker仓库也有公有和私有的概念。公有的Docker仓库名字是Docker Hub。Docker Hub提供了庞大的镜像集合供使用。这些镜像可以是你自己创建的，或者你也可以在别人的镜像基础上创建。Docker仓库是Docker的 分发 部分。
  一个Docker容器包含了所有的某个应用运行所需要的环境。每一个Docker容器都是从Docker镜像创建 的。Docker容器可以运行、开始、停止、移动和删除。每一个Docker容器都是独立和安全的应用平台。Docker容器是Docker的 运行 部分。

Docker镜像从这些基础的镜像创建，通过一种简单、具有描述性的步骤，我们称之为 指令(instructions)。
每一个指令会在镜像中创建一个新的层，指令可以包含这些动作：
    运行一个命令。
    增加文件或者文件夹。
    创建一个环境变量。
    当运行容器的时候哪些程序会运行。
这些指令存储在Dockerfile文件中。当你需要建立镜像的时候，Docker可以从Dockerfile中读取这些指令并且运行，然后返回一个最终的镜像。




docker run
    -a=[]          　　　 : Attach to `STDIN`, `STDOUT` and/or `STDERR`
    -t=false        　　  : Allocate a pseudo-tty
    --sig-proxy=true　    : Proxify all received signal to the process (non-TTY mode only) false就不能用ctrl D C退出了
    -i=false        　　  : Keep STDIN open even if not attached
    -d                    : 后台运行
	--rm=false            : Automatically remove the container when it exits (incompatible with -d)
	-m=""                 : Memory limit (format: <number><optional unit>, where unit = b, k, m or g)
    -c=0                  : CPU shares (relative weight)  -c=0完全利用，=512则只能利用50%


Docker支持的网络模式有：
    none       ：关闭容器内的网络连接
    bridge     ：通过veth接口来连接容器，默认配置。
    host       ：允许容器使用host的网络堆栈信息。 注意：这种方式将允许容器访问host中类似D-BUS之类的系统服务，所以认为是不安全的。
    container  ：使用另外一个容器的网络堆栈信息。
比如当前有一个绑定了本地地址localhost的Redis容器。如果另外一个容器需要复用这个网络堆栈，则需要如下操作：
$ sudo docker run -d --name redis example/redis --bind 127.0.0.1
$ # use the redis container's network stack to access localhost
$ sudo docker run --rm -ti --net container:redis example/redis-cli -h 127.0.0.1



/etc/hosts文件中会包含容器的hostname信息，我们也可以使用--add-host这个参数来动态添加/etc/hosts中的数据。
$ /docker run -ti --add-host db-static:86.75.30.9 ubuntu cat /etc/hosts

127.0.0.1       localhost
::1             localhost ip6-localhost ip6-loopback
86.75.30.9      db-static、

package docker:build 

docker pull 10.167.202.170/hx-crawler/common-microservicehx-baidurss:0.0.1-SNAPSHOT

docker run -itdP --net over 10.167.202.170/hx-crawler/common-microservicehx-baidurss:0.0.1-SNAPSHOT  

查看容器运行
docker ps
docker ps -as

docker logs dockerid

停止容器   docker stop dockerid
搜索镜像   docker search httpd

删除镜像   docker rmi    docker rm
docker logs -f container name 噼里啪啦 一大堆....太对，清理掉

进入docker   docker exec -it 4f6889c062ba /bin/sh
             docker attach 44fc0f0582d9

删除所有容器 docker rm $(docker ps -a -q)






查看容器的root用户密码    docker logs <容器名orID> 2>&1 | grep '^User: ' | tail -n1
查看容器日志              docker logs -f <容器名orID>
删除所有镜像              docker rmi $(docker images | grep none | awk '{print $3}' | sort -r)

运行一个新容器，同时为它命名、端口映射、文件夹映射。以redmine镜像为例
docker run --name redmine -p 9003:80 -p 9023:22 -d -v /var/redmine/files:/redmine/files -v /var/redmine/mysql:/var/lib/mysql sameersbn/redmine

一个容器连接到另一个容器
docker run -i -t --name sonar -d -link mmysql:db   tpires/sonar-server
sonar
容器连接到mmysql容器，并将mmysql容器重命名为db。这样，sonar容器就可以使用db的相关的环境变量了。


当需要把一台机器上的镜像迁移到另一台机器的时候，需要保存镜像与加载镜像。
机器a                      docker save busybox-1 > /home/save.tar
机器b                      docker load < /home/save.tar

查看docker资源     docker attach $ID


从container中拷贝文件出来
sudo docker cp 7bb0e258aefe:/etc/debian_version .
拷贝7bb0e258aefe中的/etc/debian_version到当前目录下。
注意：只要7bb0e258aefe没有被删除，文件命名空间就还在，可以放心的把exit状态的container的文件拷贝出来




搭建私有仓库
首先在136机器上下载registry镜像
$ sudo docker pull registry
下载完之后我们通过该镜像启动一个容器
$ sudo docker run -d -p 5000:5000 registry
默认情况下，会将仓库存放于容器内的/tmp/registry目录下，这样如果容器被删除，则存放于容器中的镜像也会丢失，所以我们一般情况下会指定本地一个目录挂载到容器内的/tmp/registry下，如下：
$ sudo docker run -d -p 5000:5000 -v /opt/data/registry:/tmp/registry registry


sudo docker pull busybox
接下来修改一下该镜像的tag。
$ sudo docker tag busybox 192.168.112.136:5000/busybox
